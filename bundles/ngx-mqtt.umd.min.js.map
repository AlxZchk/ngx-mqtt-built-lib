{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://ngx-mqtt/lib/mqtt.model.ts","ng://ngx-mqtt/lib/mqtt.module.ts","ng://ngx-mqtt/lib/mqtt.service.ts"],"names":["MqttConnectionState","__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","MqttServiceConfig","InjectionToken","MqttClientService","MqttModule","forRoot","config","client","ngModule","MqttModule_1","providers","provide","useValue","NgModule","MqttService","options","_this","this","observables","state","BehaviorSubject","CLOSED","messages","Subject","_clientId","_generateClientId","_connectTimeout","_reconnectPeriod","_url","undefined","_onConnect","EventEmitter","_onReconnect","_onClose","_onOffline","_onError","_onEnd","_onMessage","_onSuback","_onPacketsend","_onPacketreceive","_handleOnConnect","e","connectOnCreate","keys","forEach","filterString","subscribe","next","CONNECTED","emit","_handleOnReconnect","CONNECTING","_handleOnClose","_handleOnOffline","_handleOnError","console","error","_handleOnEnd","_handleOnMessage","topic","msg","packet","cmd","_handleOnPacketsend","_handleOnPacketreceive","connect","prototype","filterMatchesTopic","fs","split","reverse","ts","match","f","pop","t","opts","extend","protocol","hostname","url","port","path","mergedOptions","clientId","reconnectPeriod","connectTimeout","end","on","stream","disconnect","force","Error","observeRetained","qos","_generalObserve","publishReplay","observe","publish","publishFn","rejected_1","using","subscription","Subscription","err","granted","granted_","unsubscribe","filter","add","merge","pipe","MqttService_1","refCount","message","Observable","create","obs","complete","unsafePublish","Math","random","toString","substr","Inject","args","Injectable","providedIn"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Stream } from 'stream';\r\nimport { MqttClient, IClientOptions, IClientPublishOptions, IPacket } from 'mqtt';\r\n\r\nexport enum MqttConnectionState {\r\n  CLOSED,\r\n  CONNECTING,\r\n  CONNECTED\r\n}\r\n\r\nexport interface IMqttServiceOptions extends IClientOptions {\r\n  /**\r\n   * whether a new connection should be created\r\n   * on creating an instance of the service\r\n   */\r\n  connectOnCreate?: boolean;\r\n  /** the hostname of the mqtt broker */\r\n  hostname?: string;\r\n  /** the port to connect with websocket to the broker */\r\n  port?: number;\r\n  /** the path parameters to connect to e.g. `/mqtt` */\r\n  path?: string;\r\n  protocol?: 'wss' | 'ws';\r\n  /** if the url is provided, hostname, port path and protocol are ignored */\r\n  url?: string;\r\n}\r\n\r\nexport interface IMqttMessage extends IPacket {\r\n  /** the mqtt topic to which this message was published to */\r\n  topic: string;\r\n  /** the payload */\r\n  payload: Uint8Array;\r\n  /** the quality of service */\r\n  qos: number;\r\n  /** if this message is a retained message */\r\n  retain: boolean;\r\n  /** if this message is a duplicate */\r\n  dup: boolean;\r\n}\r\n\r\nexport interface IPublishOptions extends IClientPublishOptions { }\r\nexport interface IOnConnectEvent extends IMqttMessage { }\r\nexport interface IOnErrorEvent extends Error {\r\n  type?: string;\r\n}\r\nexport interface IOnMessageEvent extends IMqttMessage { }\r\nexport interface IOnSubackEvent {\r\n  granted: boolean;\r\n  filter: string;\r\n}\r\n\r\nexport interface IMqttClient extends MqttClient {\r\n  stream: Stream;\r\n}\r\n\r\nexport interface IOnPacketsendEvent extends IPacket { }\r\nexport interface IOnPacketreceiveEvent extends IPacket { }\r\n","import {\r\n  NgModule,\r\n  ModuleWithProviders,\r\n  InjectionToken\r\n} from '@angular/core';\r\nimport { IMqttClient, IMqttServiceOptions } from './mqtt.model';\r\n\r\nexport const MQTT_SERVICE_OPTIONS: IMqttServiceOptions = {\r\n  connectOnCreate: true,\r\n  hostname: 'localhost',\r\n  port: 1884,\r\n  path: ''\r\n};\r\n\r\nexport const MqttServiceConfig = new InjectionToken<IMqttServiceOptions>('NgxMqttServiceConfig');\r\nexport const MqttClientService = new InjectionToken<IMqttClient>('NgxMqttClientService');\r\n\r\n@NgModule()\r\nexport class MqttModule {\r\n  static forRoot(config: IMqttServiceOptions, client?: IMqttClient): ModuleWithProviders<MqttModule> {\r\n    return {\r\n      ngModule: MqttModule,\r\n      providers: [\r\n        {\r\n          provide: MqttServiceConfig,\r\n          useValue: config\r\n        },\r\n        {\r\n          provide: MqttClientService,\r\n          useValue: client\r\n        }\r\n      ]\r\n    };\r\n  }\r\n}\r\n","import {EventEmitter, Inject, Injectable} from '@angular/core';\r\nimport {connect, IClientSubscribeOptions, ISubscriptionGrant} from 'mqtt';\r\nimport * as extend from 'xtend';\r\n\r\nimport {BehaviorSubject, merge, Observable, Observer, Subject, Subscription, Unsubscribable, using} from 'rxjs';\r\nimport {filter, publish, publishReplay, refCount} from 'rxjs/operators';\r\n\r\nimport {\r\n  IMqttClient,\r\n  IMqttMessage,\r\n  IMqttServiceOptions,\r\n  IOnConnectEvent,\r\n  IOnErrorEvent,\r\n  IOnMessageEvent,\r\n  IOnPacketreceiveEvent,\r\n  IOnPacketsendEvent,\r\n  IOnSubackEvent,\r\n  IPublishOptions,\r\n  MqttConnectionState\r\n} from './mqtt.model';\r\n\r\nimport {MqttClientService, MqttServiceConfig} from './mqtt.module';\r\n\r\n/**\r\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\r\n * to only subscribe to the broker once per MQTT filter.\r\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class MqttService {\r\n\r\n  /**\r\n   * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\r\n   * options to configure behavior of this service, like if the connection to the broker\r\n   * should be established on creation of this service or not.\r\n   */\r\n  constructor(\r\n    @Inject(MqttServiceConfig) private options: IMqttServiceOptions,\r\n    @Inject(MqttClientService) private client?: IMqttClient\r\n  ) {\r\n    if (options.connectOnCreate !== false) {\r\n      this.connect({}, client);\r\n    }\r\n\r\n    this.state.subscribe();\r\n  }\r\n\r\n  /**\r\n   * gets the _clientId\r\n   */\r\n  public get clientId() {\r\n    return this._clientId;\r\n  }\r\n\r\n  /** An EventEmitter to listen to connect messages */\r\n  public get onConnect(): EventEmitter<IOnConnectEvent> {\r\n    return this._onConnect;\r\n  }\r\n\r\n  /** An EventEmitter to listen to reconnect messages */\r\n  public get onReconnect(): EventEmitter<void> {\r\n    return this._onReconnect;\r\n  }\r\n\r\n  /** An EventEmitter to listen to close messages */\r\n  public get onClose(): EventEmitter<void> {\r\n    return this._onClose;\r\n  }\r\n\r\n  /** An EventEmitter to listen to offline events */\r\n  public get onOffline(): EventEmitter<void> {\r\n    return this._onOffline;\r\n  }\r\n\r\n  /** An EventEmitter to listen to error events */\r\n  public get onError(): EventEmitter<IOnErrorEvent> {\r\n    return this._onError;\r\n  }\r\n\r\n  /** An EventEmitter to listen to close messages */\r\n  public get onEnd(): EventEmitter<void> {\r\n    return this._onEnd;\r\n  }\r\n\r\n  /** An EventEmitter to listen to message events */\r\n  public get onMessage(): EventEmitter<IOnMessageEvent> {\r\n    return this._onMessage;\r\n  }\r\n\r\n  /** An EventEmitter to listen to packetsend messages */\r\n  public get onPacketsend(): EventEmitter<IOnPacketsendEvent> {\r\n    return this._onPacketsend;\r\n  }\r\n\r\n  /** An EventEmitter to listen to packetreceive messages */\r\n  public get onPacketreceive(): EventEmitter<IOnPacketreceiveEvent> {\r\n    return this._onPacketreceive;\r\n  }\r\n\r\n  /** An EventEmitter to listen to suback events */\r\n  public get onSuback(): EventEmitter<IOnSubackEvent> {\r\n    return this._onSuback;\r\n  }\r\n  /** a map of all mqtt observables by filter */\r\n  public observables: { [filterString: string]: Observable<IMqttMessage> } = {};\r\n  /** the connection state */\r\n  public state: BehaviorSubject<MqttConnectionState> = new BehaviorSubject(MqttConnectionState.CLOSED);\r\n  /** an observable of the last mqtt message */\r\n  public messages: Subject<IMqttMessage> = new Subject<IMqttMessage>();\r\n\r\n  private _clientId = this._generateClientId();\r\n  private _connectTimeout = 10000;\r\n  private _reconnectPeriod = 10000;\r\n  private _url: string | undefined = undefined;\r\n\r\n  private _onConnect: EventEmitter<IOnConnectEvent> = new EventEmitter<IOnConnectEvent>();\r\n  private _onReconnect: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onClose: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onOffline: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onError: EventEmitter<IOnErrorEvent> = new EventEmitter<IOnErrorEvent>();\r\n  private _onEnd: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onMessage: EventEmitter<IOnMessageEvent> = new EventEmitter<IOnMessageEvent>();\r\n  private _onSuback: EventEmitter<IOnSubackEvent> = new EventEmitter<IOnSubackEvent>();\r\n  private _onPacketsend: EventEmitter<IOnPacketsendEvent> = new EventEmitter<IOnPacketsendEvent>();\r\n  private _onPacketreceive: EventEmitter<IOnPacketreceiveEvent> = new EventEmitter<IOnPacketreceiveEvent>();\r\n\r\n  /**\r\n   * This static method shall be used to determine whether a MQTT\r\n   * topic matches a given filter. The matching rules are specified in the MQTT\r\n   * standard documentation and in the library test suite.\r\n   *\r\n   * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\r\n   * @param  {string}  topic  A topic may not contain wildcards.\r\n   * @return {boolean}        true on match and false otherwise.\r\n   */\r\n  public static filterMatchesTopic(filterString: string, topic: string): boolean {\r\n    if (filterString[0] === '#' && topic[0] === '$') {\r\n      return false;\r\n    }\r\n    // Preparation: split and reverse on '/'. The JavaScript split function is sane.\r\n    const fs = (filterString || '').split('/').reverse();\r\n    const ts = (topic || '').split('/').reverse();\r\n    // This function is tail recursive and compares both arrays one element at a time.\r\n    const match = (): boolean => {\r\n      // Cutting of the last element of both the filter and the topic using pop().\r\n      const f = fs.pop();\r\n      const t = ts.pop();\r\n      switch (f) {\r\n        // In case the filter level is '#', this is a match no matter whether\r\n        // the topic is undefined on this level or not ('#' matches parent element as well!).\r\n        case '#':\r\n          return true;\r\n        // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\r\n        case '+':\r\n          return t ? match() : false;\r\n        // In all other cases the filter level must match the topic level,\r\n        // both must be defined and the filter tail must match the topic\r\n        // tail (which is determined by the recursive call of match()).\r\n        default:\r\n          return f === t && (f === undefined ? true : match());\r\n      }\r\n    };\r\n    return match();\r\n  }\r\n\r\n  /**\r\n   * connect manually connects to the mqtt broker.\r\n   */\r\n  public connect(opts?: IMqttServiceOptions, client?: IMqttClient) {\r\n    const options = extend(this.options || {}, opts);\r\n    const protocol = options.protocol || 'ws';\r\n    const hostname = options.hostname || 'localhost';\r\n    if (options.url) {\r\n      this._url = options.url;\r\n    } else {\r\n      this._url = `${protocol}://${hostname}`;\r\n      this._url += options.port ? `:${options.port}` : '';\r\n      this._url += options.path ? `${options.path}` : '';\r\n    }\r\n    this.state.next(MqttConnectionState.CONNECTING);\r\n    const mergedOptions = extend({\r\n      clientId: this._clientId,\r\n      reconnectPeriod: this._reconnectPeriod,\r\n      connectTimeout: this._connectTimeout\r\n    }, options);\r\n\r\n    if (this.client) {\r\n      this.client.end(true);\r\n    }\r\n\r\n    if (!client) {\r\n      this.client = (connect(this._url, mergedOptions) as IMqttClient);\r\n    } else {\r\n      this.client = client;\r\n    }\r\n    this._clientId = mergedOptions.clientId;\r\n\r\n    this.client.on('connect', this._handleOnConnect);\r\n    this.client.on('reconnect', this._handleOnReconnect);\r\n    this.client.on('close', this._handleOnClose);\r\n    this.client.on('offline', this._handleOnOffline);\r\n    this.client.on('error', this._handleOnError);\r\n    this.client.stream.on('error', this._handleOnError);\r\n    this.client.on('end', this._handleOnEnd);\r\n    this.client.on('message', this._handleOnMessage);\r\n    this.client.on('packetsend', this._handleOnPacketsend);\r\n    this.client.on('packetreceive', this._handleOnPacketreceive);\r\n  }\r\n\r\n  /**\r\n   * disconnect disconnects from the mqtt client.\r\n   * This method `should` be executed when leaving the application.\r\n   */\r\n  public disconnect(force = true) {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    this.client.end(force);\r\n  }\r\n\r\n  /**\r\n   * With this method, you can observe messages for a mqtt topic.\r\n   * The observable will only emit messages matching the filter.\r\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\r\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\r\n   * Every new subscriber gets the latest message.\r\n   */\r\n  public observeRetained(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\r\n    return this._generalObserve(filterString, () => publishReplay(1), opts);\r\n  }\r\n\r\n  /**\r\n   * With this method, you can observe messages for a mqtt topic.\r\n   * The observable will only emit messages matching the filter.\r\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\r\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\r\n   */\r\n  public observe(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\r\n    return this._generalObserve(filterString, () => publish(), opts);\r\n  }\r\n\r\n  /**\r\n   * With this method, you can observe messages for a mqtt topic.\r\n   * The observable will only emit messages matching the filter.\r\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\r\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\r\n   * Depending on the publish function, the messages will either be replayed after new\r\n   * subscribers subscribe or the messages are just passed through\r\n   */\r\n  private _generalObserve(filterString: string, publishFn: Function, opts: IClientSubscribeOptions): Observable<IMqttMessage> {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    if (!this.observables[filterString]) {\r\n      const rejected: Subject<IMqttMessage> = new Subject();\r\n      this.observables[filterString] = using(\r\n        // resourceFactory: Do the actual ref-counting MQTT subscription.\r\n        // refcount is decreased on unsubscribe.\r\n        () => {\r\n          const subscription: Subscription = new Subscription();\r\n          this.client.subscribe(filterString, opts, (err, granted: ISubscriptionGrant[]) => {\r\n            if (granted) { // granted can be undefined when an error occurs when the client is disconnecting\r\n              granted.forEach((granted_: ISubscriptionGrant) => {\r\n                if (granted_.qos === 128) {\r\n                  delete this.observables[granted_.topic];\r\n                  this.client.unsubscribe(granted_.topic);\r\n                  rejected.error(`subscription for '${granted_.topic}' rejected!`);\r\n                }\r\n                this._onSuback.emit({filter: filterString, granted: granted_.qos !== 128});\r\n              });\r\n            }\r\n          });\r\n          subscription.add(() => {\r\n            delete this.observables[filterString];\r\n            this.client.unsubscribe(filterString);\r\n          });\r\n          return subscription;\r\n        },\r\n        // observableFactory: Create the observable that is consumed from.\r\n        // This part is not executed until the Observable returned by\r\n        // `observe` gets actually subscribed.\r\n        (subscription: Unsubscribable | void) => merge(rejected, this.messages))\r\n        .pipe(\r\n          filter((msg: IMqttMessage) => MqttService.filterMatchesTopic(filterString, msg.topic)),\r\n          publishFn(),\r\n          refCount()\r\n        ) as Observable<IMqttMessage>;\r\n    }\r\n    return this.observables[filterString];\r\n  }\r\n\r\n  /**\r\n   * This method returns an observable for a topic with optional options.\r\n   * After subscribing, the actual mqtt publication will be executed and\r\n   * the observable will emit an empty value and completes, if publishing was successful\r\n   * or throws an error, if the publication fails.\r\n   */\r\n  public publish(topic: string, message: string | Buffer, options?: IPublishOptions): Observable<void> {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    return Observable.create((obs: Observer<void>) => {\r\n      this.client.publish(topic, message, options, (err: Error) => {\r\n        if (err) {\r\n          obs.error(err);\r\n        } else {\r\n          obs.next(null);\r\n          obs.complete();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This method publishes a message for a topic with optional options.\r\n   * If an error occurs, it will throw.\r\n   */\r\n  public unsafePublish(topic: string, message: string | Buffer, options?: IPublishOptions): void {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    this.client.publish(topic, message, options, (err: Error) => {\r\n      if (err) {\r\n        throw (err);\r\n      }\r\n    });\r\n  }\r\n\r\n  private _handleOnConnect = (e: IOnConnectEvent) => {\r\n    if (this.options.connectOnCreate === true) {\r\n      Object.keys(this.observables).forEach((filterString: string) => {\r\n        this.client.subscribe(filterString);\r\n      });\r\n    }\r\n    this.state.next(MqttConnectionState.CONNECTED);\r\n    this._onConnect.emit(e);\r\n  }\r\n\r\n  private _handleOnReconnect = () => {\r\n    if (this.options.connectOnCreate === true) {\r\n      Object.keys(this.observables).forEach((filterString: string) => {\r\n        this.client.subscribe(filterString);\r\n      });\r\n    }\r\n    this.state.next(MqttConnectionState.CONNECTING);\r\n    this._onReconnect.emit();\r\n  }\r\n\r\n  private _handleOnClose = () => {\r\n    this.state.next(MqttConnectionState.CLOSED);\r\n    this._onClose.emit();\r\n  }\r\n\r\n  private _handleOnOffline = () => {\r\n    this._onOffline.emit();\r\n  }\r\n\r\n  private _handleOnError = (e: IOnErrorEvent) => {\r\n    this._onError.emit(e);\r\n    console.error(e);\r\n  }\r\n\r\n  private _handleOnEnd = () => {\r\n    this._onEnd.emit();\r\n  }\r\n\r\n  private _handleOnMessage = (topic: string, msg, packet: IMqttMessage) => {\r\n    this._onMessage.emit(packet);\r\n    if (packet.cmd === 'publish') {\r\n      this.messages.next(packet);\r\n    }\r\n  }\r\n\r\n  private _handleOnPacketsend = (e: IOnPacketsendEvent) => {\r\n    this._onPacketsend.emit();\r\n  }\r\n\r\n  private _handleOnPacketreceive = (e: IOnPacketreceiveEvent) => {\r\n    this._onPacketreceive.emit();\r\n  }\r\n\r\n  private _generateClientId() {\r\n    return 'client-' + Math.random().toString(36).substr(2, 19);\r\n  }\r\n}\r\n"]}