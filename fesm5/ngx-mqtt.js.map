{"version":3,"file":"ngx-mqtt.js","sources":["ng://ngx-mqtt/lib/mqtt.model.ts","ng://ngx-mqtt/lib/mqtt.module.ts","ng://ngx-mqtt/lib/mqtt.service.ts","ng://ngx-mqtt/public-api.ts","ng://ngx-mqtt/ngx-mqtt.ts"],"sourcesContent":["import { Stream } from 'stream';\r\nimport { MqttClient, IClientOptions, IClientPublishOptions, IPacket } from 'mqtt';\r\n\r\nexport enum MqttConnectionState {\r\n  CLOSED,\r\n  CONNECTING,\r\n  CONNECTED\r\n}\r\n\r\nexport interface IMqttServiceOptions extends IClientOptions {\r\n  /**\r\n   * whether a new connection should be created\r\n   * on creating an instance of the service\r\n   */\r\n  connectOnCreate?: boolean;\r\n  /** the hostname of the mqtt broker */\r\n  hostname?: string;\r\n  /** the port to connect with websocket to the broker */\r\n  port?: number;\r\n  /** the path parameters to connect to e.g. `/mqtt` */\r\n  path?: string;\r\n  protocol?: 'wss' | 'ws';\r\n  /** if the url is provided, hostname, port path and protocol are ignored */\r\n  url?: string;\r\n}\r\n\r\nexport interface IMqttMessage extends IPacket {\r\n  /** the mqtt topic to which this message was published to */\r\n  topic: string;\r\n  /** the payload */\r\n  payload: Uint8Array;\r\n  /** the quality of service */\r\n  qos: number;\r\n  /** if this message is a retained message */\r\n  retain: boolean;\r\n  /** if this message is a duplicate */\r\n  dup: boolean;\r\n}\r\n\r\nexport interface IPublishOptions extends IClientPublishOptions { }\r\nexport interface IOnConnectEvent extends IMqttMessage { }\r\nexport interface IOnErrorEvent extends Error {\r\n  type?: string;\r\n}\r\nexport interface IOnMessageEvent extends IMqttMessage { }\r\nexport interface IOnSubackEvent {\r\n  granted: boolean;\r\n  filter: string;\r\n}\r\n\r\nexport interface IMqttClient extends MqttClient {\r\n  stream: Stream;\r\n}\r\n\r\nexport interface IOnPacketsendEvent extends IPacket { }\r\nexport interface IOnPacketreceiveEvent extends IPacket { }\r\n","import {\r\n  NgModule,\r\n  ModuleWithProviders,\r\n  InjectionToken\r\n} from '@angular/core';\r\nimport { IMqttClient, IMqttServiceOptions } from './mqtt.model';\r\n\r\nexport const MQTT_SERVICE_OPTIONS: IMqttServiceOptions = {\r\n  connectOnCreate: true,\r\n  hostname: 'localhost',\r\n  port: 1884,\r\n  path: ''\r\n};\r\n\r\nexport const MqttServiceConfig = new InjectionToken<IMqttServiceOptions>('NgxMqttServiceConfig');\r\nexport const MqttClientService = new InjectionToken<IMqttClient>('NgxMqttClientService');\r\n\r\n@NgModule()\r\nexport class MqttModule {\r\n  static forRoot(config: IMqttServiceOptions, client?: IMqttClient): ModuleWithProviders<MqttModule> {\r\n    return {\r\n      ngModule: MqttModule,\r\n      providers: [\r\n        {\r\n          provide: MqttServiceConfig,\r\n          useValue: config\r\n        },\r\n        {\r\n          provide: MqttClientService,\r\n          useValue: client\r\n        }\r\n      ]\r\n    };\r\n  }\r\n}\r\n","import {EventEmitter, Inject, Injectable} from '@angular/core';\r\nimport {connect, IClientSubscribeOptions, ISubscriptionGrant} from 'mqtt';\r\nimport * as extend from 'xtend';\r\n\r\nimport {BehaviorSubject, merge, Observable, Observer, Subject, Subscription, Unsubscribable, using} from 'rxjs';\r\nimport {filter, publish, publishReplay, refCount} from 'rxjs/operators';\r\n\r\nimport {\r\n  IMqttClient,\r\n  IMqttMessage,\r\n  IMqttServiceOptions,\r\n  IOnConnectEvent,\r\n  IOnErrorEvent,\r\n  IOnMessageEvent,\r\n  IOnPacketreceiveEvent,\r\n  IOnPacketsendEvent,\r\n  IOnSubackEvent,\r\n  IPublishOptions,\r\n  MqttConnectionState\r\n} from './mqtt.model';\r\n\r\nimport {MqttClientService, MqttServiceConfig} from './mqtt.module';\r\n\r\n/**\r\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\r\n * to only subscribe to the broker once per MQTT filter.\r\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class MqttService {\r\n\r\n  /**\r\n   * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\r\n   * options to configure behavior of this service, like if the connection to the broker\r\n   * should be established on creation of this service or not.\r\n   */\r\n  constructor(\r\n    @Inject(MqttServiceConfig) private options: IMqttServiceOptions,\r\n    @Inject(MqttClientService) private client?: IMqttClient\r\n  ) {\r\n    if (options.connectOnCreate !== false) {\r\n      this.connect({}, client);\r\n    }\r\n\r\n    this.state.subscribe();\r\n  }\r\n\r\n  /**\r\n   * gets the _clientId\r\n   */\r\n  public get clientId() {\r\n    return this._clientId;\r\n  }\r\n\r\n  /** An EventEmitter to listen to connect messages */\r\n  public get onConnect(): EventEmitter<IOnConnectEvent> {\r\n    return this._onConnect;\r\n  }\r\n\r\n  /** An EventEmitter to listen to reconnect messages */\r\n  public get onReconnect(): EventEmitter<void> {\r\n    return this._onReconnect;\r\n  }\r\n\r\n  /** An EventEmitter to listen to close messages */\r\n  public get onClose(): EventEmitter<void> {\r\n    return this._onClose;\r\n  }\r\n\r\n  /** An EventEmitter to listen to offline events */\r\n  public get onOffline(): EventEmitter<void> {\r\n    return this._onOffline;\r\n  }\r\n\r\n  /** An EventEmitter to listen to error events */\r\n  public get onError(): EventEmitter<IOnErrorEvent> {\r\n    return this._onError;\r\n  }\r\n\r\n  /** An EventEmitter to listen to close messages */\r\n  public get onEnd(): EventEmitter<void> {\r\n    return this._onEnd;\r\n  }\r\n\r\n  /** An EventEmitter to listen to message events */\r\n  public get onMessage(): EventEmitter<IOnMessageEvent> {\r\n    return this._onMessage;\r\n  }\r\n\r\n  /** An EventEmitter to listen to packetsend messages */\r\n  public get onPacketsend(): EventEmitter<IOnPacketsendEvent> {\r\n    return this._onPacketsend;\r\n  }\r\n\r\n  /** An EventEmitter to listen to packetreceive messages */\r\n  public get onPacketreceive(): EventEmitter<IOnPacketreceiveEvent> {\r\n    return this._onPacketreceive;\r\n  }\r\n\r\n  /** An EventEmitter to listen to suback events */\r\n  public get onSuback(): EventEmitter<IOnSubackEvent> {\r\n    return this._onSuback;\r\n  }\r\n  /** a map of all mqtt observables by filter */\r\n  public observables: { [filterString: string]: Observable<IMqttMessage> } = {};\r\n  /** the connection state */\r\n  public state: BehaviorSubject<MqttConnectionState> = new BehaviorSubject(MqttConnectionState.CLOSED);\r\n  /** an observable of the last mqtt message */\r\n  public messages: Subject<IMqttMessage> = new Subject<IMqttMessage>();\r\n\r\n  private _clientId = this._generateClientId();\r\n  private _connectTimeout = 10000;\r\n  private _reconnectPeriod = 10000;\r\n  private _url: string | undefined = undefined;\r\n\r\n  private _onConnect: EventEmitter<IOnConnectEvent> = new EventEmitter<IOnConnectEvent>();\r\n  private _onReconnect: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onClose: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onOffline: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onError: EventEmitter<IOnErrorEvent> = new EventEmitter<IOnErrorEvent>();\r\n  private _onEnd: EventEmitter<void> = new EventEmitter<void>();\r\n  private _onMessage: EventEmitter<IOnMessageEvent> = new EventEmitter<IOnMessageEvent>();\r\n  private _onSuback: EventEmitter<IOnSubackEvent> = new EventEmitter<IOnSubackEvent>();\r\n  private _onPacketsend: EventEmitter<IOnPacketsendEvent> = new EventEmitter<IOnPacketsendEvent>();\r\n  private _onPacketreceive: EventEmitter<IOnPacketreceiveEvent> = new EventEmitter<IOnPacketreceiveEvent>();\r\n\r\n  /**\r\n   * This static method shall be used to determine whether a MQTT\r\n   * topic matches a given filter. The matching rules are specified in the MQTT\r\n   * standard documentation and in the library test suite.\r\n   *\r\n   * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\r\n   * @param  {string}  topic  A topic may not contain wildcards.\r\n   * @return {boolean}        true on match and false otherwise.\r\n   */\r\n  public static filterMatchesTopic(filterString: string, topic: string): boolean {\r\n    if (filterString[0] === '#' && topic[0] === '$') {\r\n      return false;\r\n    }\r\n    // Preparation: split and reverse on '/'. The JavaScript split function is sane.\r\n    const fs = (filterString || '').split('/').reverse();\r\n    const ts = (topic || '').split('/').reverse();\r\n    // This function is tail recursive and compares both arrays one element at a time.\r\n    const match = (): boolean => {\r\n      // Cutting of the last element of both the filter and the topic using pop().\r\n      const f = fs.pop();\r\n      const t = ts.pop();\r\n      switch (f) {\r\n        // In case the filter level is '#', this is a match no matter whether\r\n        // the topic is undefined on this level or not ('#' matches parent element as well!).\r\n        case '#':\r\n          return true;\r\n        // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\r\n        case '+':\r\n          return t ? match() : false;\r\n        // In all other cases the filter level must match the topic level,\r\n        // both must be defined and the filter tail must match the topic\r\n        // tail (which is determined by the recursive call of match()).\r\n        default:\r\n          return f === t && (f === undefined ? true : match());\r\n      }\r\n    };\r\n    return match();\r\n  }\r\n\r\n  /**\r\n   * connect manually connects to the mqtt broker.\r\n   */\r\n  public connect(opts?: IMqttServiceOptions, client?: IMqttClient) {\r\n    const options = extend(this.options || {}, opts);\r\n    const protocol = options.protocol || 'ws';\r\n    const hostname = options.hostname || 'localhost';\r\n    if (options.url) {\r\n      this._url = options.url;\r\n    } else {\r\n      this._url = `${protocol}://${hostname}`;\r\n      this._url += options.port ? `:${options.port}` : '';\r\n      this._url += options.path ? `${options.path}` : '';\r\n    }\r\n    this.state.next(MqttConnectionState.CONNECTING);\r\n    const mergedOptions = extend({\r\n      clientId: this._clientId,\r\n      reconnectPeriod: this._reconnectPeriod,\r\n      connectTimeout: this._connectTimeout\r\n    }, options);\r\n\r\n    if (this.client) {\r\n      this.client.end(true);\r\n    }\r\n\r\n    if (!client) {\r\n      this.client = (connect(this._url, mergedOptions) as IMqttClient);\r\n    } else {\r\n      this.client = client;\r\n    }\r\n    this._clientId = mergedOptions.clientId;\r\n\r\n    this.client.on('connect', this._handleOnConnect);\r\n    this.client.on('reconnect', this._handleOnReconnect);\r\n    this.client.on('close', this._handleOnClose);\r\n    this.client.on('offline', this._handleOnOffline);\r\n    this.client.on('error', this._handleOnError);\r\n    this.client.stream.on('error', this._handleOnError);\r\n    this.client.on('end', this._handleOnEnd);\r\n    this.client.on('message', this._handleOnMessage);\r\n    this.client.on('packetsend', this._handleOnPacketsend);\r\n    this.client.on('packetreceive', this._handleOnPacketreceive);\r\n  }\r\n\r\n  /**\r\n   * disconnect disconnects from the mqtt client.\r\n   * This method `should` be executed when leaving the application.\r\n   */\r\n  public disconnect(force = true) {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    this.client.end(force);\r\n  }\r\n\r\n  /**\r\n   * With this method, you can observe messages for a mqtt topic.\r\n   * The observable will only emit messages matching the filter.\r\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\r\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\r\n   * Every new subscriber gets the latest message.\r\n   */\r\n  public observeRetained(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\r\n    return this._generalObserve(filterString, () => publishReplay(1), opts);\r\n  }\r\n\r\n  /**\r\n   * With this method, you can observe messages for a mqtt topic.\r\n   * The observable will only emit messages matching the filter.\r\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\r\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\r\n   */\r\n  public observe(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\r\n    return this._generalObserve(filterString, () => publish(), opts);\r\n  }\r\n\r\n  /**\r\n   * With this method, you can observe messages for a mqtt topic.\r\n   * The observable will only emit messages matching the filter.\r\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\r\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\r\n   * Depending on the publish function, the messages will either be replayed after new\r\n   * subscribers subscribe or the messages are just passed through\r\n   */\r\n  private _generalObserve(filterString: string, publishFn: Function, opts: IClientSubscribeOptions): Observable<IMqttMessage> {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    if (!this.observables[filterString]) {\r\n      const rejected: Subject<IMqttMessage> = new Subject();\r\n      this.observables[filterString] = using(\r\n        // resourceFactory: Do the actual ref-counting MQTT subscription.\r\n        // refcount is decreased on unsubscribe.\r\n        () => {\r\n          const subscription: Subscription = new Subscription();\r\n          this.client.subscribe(filterString, opts, (err, granted: ISubscriptionGrant[]) => {\r\n            if (granted) { // granted can be undefined when an error occurs when the client is disconnecting\r\n              granted.forEach((granted_: ISubscriptionGrant) => {\r\n                if (granted_.qos === 128) {\r\n                  delete this.observables[granted_.topic];\r\n                  this.client.unsubscribe(granted_.topic);\r\n                  rejected.error(`subscription for '${granted_.topic}' rejected!`);\r\n                }\r\n                this._onSuback.emit({filter: filterString, granted: granted_.qos !== 128});\r\n              });\r\n            }\r\n          });\r\n          subscription.add(() => {\r\n            delete this.observables[filterString];\r\n            this.client.unsubscribe(filterString);\r\n          });\r\n          return subscription;\r\n        },\r\n        // observableFactory: Create the observable that is consumed from.\r\n        // This part is not executed until the Observable returned by\r\n        // `observe` gets actually subscribed.\r\n        (subscription: Unsubscribable | void) => merge(rejected, this.messages))\r\n        .pipe(\r\n          filter((msg: IMqttMessage) => MqttService.filterMatchesTopic(filterString, msg.topic)),\r\n          publishFn(),\r\n          refCount()\r\n        ) as Observable<IMqttMessage>;\r\n    }\r\n    return this.observables[filterString];\r\n  }\r\n\r\n  /**\r\n   * This method returns an observable for a topic with optional options.\r\n   * After subscribing, the actual mqtt publication will be executed and\r\n   * the observable will emit an empty value and completes, if publishing was successful\r\n   * or throws an error, if the publication fails.\r\n   */\r\n  public publish(topic: string, message: string | Buffer, options?: IPublishOptions): Observable<void> {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    return Observable.create((obs: Observer<void>) => {\r\n      this.client.publish(topic, message, options, (err: Error) => {\r\n        if (err) {\r\n          obs.error(err);\r\n        } else {\r\n          obs.next(null);\r\n          obs.complete();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This method publishes a message for a topic with optional options.\r\n   * If an error occurs, it will throw.\r\n   */\r\n  public unsafePublish(topic: string, message: string | Buffer, options?: IPublishOptions): void {\r\n    if (!this.client) {\r\n      throw new Error('mqtt client not connected');\r\n    }\r\n    this.client.publish(topic, message, options, (err: Error) => {\r\n      if (err) {\r\n        throw (err);\r\n      }\r\n    });\r\n  }\r\n\r\n  private _handleOnConnect = (e: IOnConnectEvent) => {\r\n    if (this.options.connectOnCreate === true) {\r\n      Object.keys(this.observables).forEach((filterString: string) => {\r\n        this.client.subscribe(filterString);\r\n      });\r\n    }\r\n    this.state.next(MqttConnectionState.CONNECTED);\r\n    this._onConnect.emit(e);\r\n  }\r\n\r\n  private _handleOnReconnect = () => {\r\n    if (this.options.connectOnCreate === true) {\r\n      Object.keys(this.observables).forEach((filterString: string) => {\r\n        this.client.subscribe(filterString);\r\n      });\r\n    }\r\n    this.state.next(MqttConnectionState.CONNECTING);\r\n    this._onReconnect.emit();\r\n  }\r\n\r\n  private _handleOnClose = () => {\r\n    this.state.next(MqttConnectionState.CLOSED);\r\n    this._onClose.emit();\r\n  }\r\n\r\n  private _handleOnOffline = () => {\r\n    this._onOffline.emit();\r\n  }\r\n\r\n  private _handleOnError = (e: IOnErrorEvent) => {\r\n    this._onError.emit(e);\r\n    console.error(e);\r\n  }\r\n\r\n  private _handleOnEnd = () => {\r\n    this._onEnd.emit();\r\n  }\r\n\r\n  private _handleOnMessage = (topic: string, msg, packet: IMqttMessage) => {\r\n    this._onMessage.emit(packet);\r\n    if (packet.cmd === 'publish') {\r\n      this.messages.next(packet);\r\n    }\r\n  }\r\n\r\n  private _handleOnPacketsend = (e: IOnPacketsendEvent) => {\r\n    this._onPacketsend.emit();\r\n  }\r\n\r\n  private _handleOnPacketreceive = (e: IOnPacketreceiveEvent) => {\r\n    this._onPacketreceive.emit();\r\n  }\r\n\r\n  private _generateClientId() {\r\n    return 'client-' + Math.random().toString(36).substr(2, 19);\r\n  }\r\n}\r\n","/*\r\n * Public API Surface of ngx-mqtt\r\n */\r\n\r\nexport * from './lib/mqtt.model';\r\nexport * from './lib/mqtt.service';\r\nexport * from './lib/mqtt.module';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}